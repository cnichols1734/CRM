# CRM Project - Cursor AI Rules

## Project Overview
This is a Flask-based CRM application for Origen Realty real estate agents.
- **Framework**: Flask with SQLAlchemy
- **Database**: Supabase PostgreSQL (connection string in `.env`)
- **Hosting**: PythonAnywhere (www.origentechnolog.com)
- **Repo**: https://github.com/cnichols1734/CRM

## Local Development
- **Port**: 5011
- **Start command**: `python3 app.py` (from project root)
- **Local URL**: http://127.0.0.1:5011

## Testing Rules
Never auto test UI tests unless I specifically ask for it  
- Once a feature is complete ask me if I am ready to push a PR for it before pushing it

## Testing Credentials
Test credentials are stored in the `.env` file:
- `TEST_USERNAME` - email for login
- `TEST_PASSWORD` - password for login

When testing features locally, read the `.env` file to get these credentials, then use the browser tools to:
1. Navigate to http://127.0.0.1:5011
2. Login with the test credentials
3. Test the feature

## AI Features
All AI features use a centralized service with GPT-5.1 fallback chain:
- **Service file**: `services/ai_service.py`
- **Model hierarchy**: GPT-5.1 → GPT-5-mini → GPT-4o

AI feature routes (each has its own custom prompt):
- `routes/action_plan.py` - 2026 Lead Generation Action Plan
- `routes/daily_todo.py` - AI-generated daily task list
- `routes/ai_chat.py` - B.O.B. (Business Optimization Buddy) chat assistant

## Transaction & Document Management System

### Overview
Complete transaction management and e-signature workflow for real estate deals. Currently supports Seller Conventional transactions with DocuSeal integration for e-signatures.

### Key Files
| File | Purpose |
|------|---------|
| `routes/transactions.py` | All transaction routes (CRUD, intake, documents, e-signature) |
| `services/docuseal_service.py` | DocuSeal API integration (mock mode available) |
| `services/intake_service.py` | Schema loading, document rules engine |
| `intake_schemas/seller_conventional.json` | Questionnaire + document rules for seller transactions |
| `templates/transactions/` | List, create, detail, intake, document_form templates |
| `seller_docs/` | PDF templates for seller conventional workflow |

### Database Models (in `models.py`)
- **TransactionType**: Lookup table (Seller Representation, Buyer Representation, Dual Agency)
- **Transaction**: Main transaction record with address, status, intake_data (JSON)
- **TransactionParticipant**: Links contacts/users to transactions with roles (seller, buyer, listing_agent, etc.)
- **TransactionDocument**: Documents in transaction package with status lifecycle
- **DocumentSignature**: Individual signer records for e-signature tracking

### Document Status Lifecycle
```
pending → filled → sent → signed
```

Each status has different available actions in the UI dropdown.

### Schema-Driven Architecture
Intake questionnaires and document rules are defined in JSON schemas:
- `intake_schemas/seller_conventional.json` - Questions + document rules
- Schema defines: questions, options, document rules (always/conditional)
- Rules engine evaluates answers to determine required documents

### DocuSeal Integration
**Current State**: Mock mode for full E2E testing
**Service**: `services/docuseal_service.py`

Key functions:
- `create_submission()` - Send document for signature
- `get_submission()` / `get_submission_status()` - Check status
- `build_submitters_from_participants()` - Map transaction participants to signers
- `_mock_simulate_signing()` - Test helper for E2E flow

**To enable real DocuSeal:**
1. Add `DOCUSEAL_API_KEY` to `.env`
2. Set `DOCUSEAL_MOCK_MODE=False` in `.env`
3. Upload PDF templates to DocuSeal console
4. Update `TEMPLATE_MAP` in `docuseal_service.py` with template IDs

### Feature Flag
`TRANSACTIONS_ENABLED` in `feature_flags.py` controls access.
Currently requires: flag enabled AND user.role == 'admin'

### Adding New Transaction Types
1. Create new schema file: `intake_schemas/{type}_{ownership}.json`
2. Define questions with `id`, `label`, `type`, `options`
3. Define document rules with `slug`, `name`, `condition` (always/conditional)
4. Add TransactionType record to database
5. Update create form to include new type option

### Document Form Prefilling
`build_prefill_data()` in `routes/transactions.py` gathers data from:
- Transaction (address, property info)
- Primary seller participant
- Listing agent participant
- Current user (agent info)
- Intake answers

## Deployment Workflow
After pushing changes to GitHub:
1. SSH into PythonAnywhere or use Bash console
2. Run: `cd ~/mysite && git pull origin main`
3. If new packages: `pip install -r requirements.txt --user`
4. If database migrations: `flask db upgrade`
5. Go to Web tab and click "Reload"

## Key Files
- `app.py` - Main Flask application
- `models.py` - SQLAlchemy database models
- `config.py` - Configuration (reads from .env)
- `feature_flags.py` - Feature toggles (deploys with code via git)
- `.env` - Environment variables (gitignored, contains secrets)
- `services/` - Shared services (AI, SendGrid, DocuSeal, Intake)
- `routes/` - Flask blueprints/routes
- `templates/` - Jinja2 HTML templates
- `static/` - CSS, JS, images
- `intake_schemas/` - JSON schemas for transaction questionnaires
- `seller_docs/` - PDF templates for seller document workflow

## Feature Flags
Toggle features on/off in `feature_flags.py`. Changes deploy with git pull - no need to edit .env on server.

Current flags:
- `SHOW_DASHBOARD_JOKE` - Dashboard joke of the day (fetches from external APIs)
- `TRANSACTIONS_ENABLED` - Transaction management module (admin-only when enabled)

## Database
- **Production**: Supabase PostgreSQL
- **Local test DB**: `instance/crm.db` (SQLite, for quick testing only)
- **Production data backup**: `instance/crm (1).db`
- **Migrations**: Use Flask-Migrate (`flask db migrate`, `flask db upgrade`)

## PR & Commit Rules
Always use the PR workflow - commit changes to a branch and push for review in GitHub.

### Branch & Commit Naming Convention
Use conventional commit prefixes for branches and commit messages:

| Prefix | Use For |
|--------|---------|
| `feat:` | New features (e.g., `feat: add contact import wizard`) |
| `fix:` | Bug fixes (e.g., `fix: resolve login redirect loop`) |
| `chore:` | Maintenance, dependencies, configs (e.g., `chore: update requirements.txt`) |
| `refactor:` | Code restructuring without behavior change (e.g., `refactor: extract base.html inline JS`) |
| `docs:` | Documentation only (e.g., `docs: update README with deploy steps`) |
| `style:` | Formatting, CSS, no logic change (e.g., `style: fix button alignment on mobile`) |
| `test:` | Adding or updating tests (e.g., `test: add scheduled integration tests`) |
| `perf:` | Performance improvements (e.g., `perf: optimize contact list query`) |

### Branch Naming
Use the same prefix with kebab-case description:
- `feat/contact-import-wizard`
- `fix/login-redirect-loop`
- `chore/update-dependencies`
- `refactor/base-js`

### PR Workflow
**IMPORTANT: Before starting ANY new feature or fix:**
1. Ensure you are on `main` branch
2. Run `git pull origin main` to sync with remote
3. Only then create the feature branch and begin work

**Steps:**
1. Sync with main: `git checkout main && git pull origin main`
2. Create feature branch with appropriate prefix
3. Make commits with conventional prefixes
4. Push branch to origin
5. User reviews and creates PR via GitHub UI (one-click merge)

## Important Notes
- The `.env` file is gitignored - never commit secrets
- PythonAnywhere has its own `.env` file at `~/mysite/.env`
- Transaction management is currently admin-only via feature flag
- DocuSeal is in mock mode - set `DOCUSEAL_MOCK_MODE=False` for production
